/**
 * Date Utilities for Production Schedule Reflow
 * 
 * This module provides robust date/time calculations that respect:
 * - Work center shift schedules (when work can occur)
 * - Maintenance windows (blocked periods)
 * - Timezone handling via Luxon
 * 
 * Key Concept: "Working time" vs "Calendar time"
 * - Working time: Only counts when shifts are active
 * - Calendar time: Real elapsed time including off-hours
 */

import { DateTime, Interval } from 'luxon';
import type { WorkCenter, MaintenanceWindow } from '../reflow/types';

/**
 * Represents a time slot where work can be performed.
 * These are generated by intersecting shift schedules with available dates
 * while excluding maintenance windows.
 */
interface WorkableSlot {
  start: DateTime;
  end: DateTime;
  durationMinutes: number;
}

/**
 * Calculates the end date for a work order given a start date, duration,
 * and work center constraints (shifts and maintenance windows).
 * 
 * The algorithm:
 * 1. Start from the given startDate
 * 2. Find the next available working slot
 * 3. Consume as much duration as possible in that slot
 * 4. If duration remains, find the next slot and repeat
 * 5. Return the final end date/time
 * 
 * @param startDate - When to begin scheduling (ISO string or DateTime)
 * @param durationMinutes - Total working minutes required
 * @param workCenter - Work center with shift/maintenance definitions
 * @param timezone - Timezone for shift calculations (default: UTC)
 * @returns The calculated end date as DateTime
 * 
 * @example
 * // Order starts at 4pm, needs 2 hours, shift ends at 5pm
 * // Result: 10am next day (1 hour today + 1 hour tomorrow)
 */
export function calculateEndDateWithShifts(
  startDate: string | DateTime,
  durationMinutes: number,
  workCenter: WorkCenter,
  timezone: string = 'UTC',
): DateTime {
  // Normalize start date to DateTime
  let current = typeof startDate === 'string'
    ? DateTime.fromISO(startDate, { zone: timezone })
    : startDate.setZone(timezone);

  // Handle edge case of zero duration
  if (durationMinutes <= 0) {
    return current;
  }

  let remainingMinutes = durationMinutes;
  
  // Safety limit to prevent infinite loops (max 365 days of searching)
  const maxIterations = 365 * 24; // One iteration per hour max
  let iterations = 0;

  while (remainingMinutes > 0 && iterations < maxIterations) {
    iterations++;
    
    // Find the next workable slot starting from current time
    const slot = findNextWorkableSlot(current, workCenter, timezone);
    
    if (!slot) {
      // No more workable slots found - this shouldn't happen with valid shift config
      throw new Error(
        `No workable slots found for work center "${workCenter.data.name}" ` +
        `starting from ${current.toISO()}. Check shift configuration.`
      );
    }

    // If current time is before the slot start, jump to slot start
    if (current < slot.start) {
      current = slot.start;
    }

    // Calculate how much time we can use in this slot
    const availableInSlot = slot.end.diff(current, 'minutes').minutes;
    
    if (availableInSlot <= 0) {
      // Move to end of slot and continue searching
      current = slot.end;
      continue;
    }

    if (remainingMinutes <= availableInSlot) {
      // We can finish in this slot
      current = current.plus({ minutes: remainingMinutes });
      remainingMinutes = 0;
    } else {
      // Consume entire slot and continue
      remainingMinutes -= availableInSlot;
      current = slot.end;
    }
  }

  if (iterations >= maxIterations) {
    throw new Error(
      `Could not schedule work order within reasonable time frame. ` +
      `Duration: ${durationMinutes} minutes, Work Center: ${workCenter.data.name}`
    );
  }

  return current;
}

/**
 * Finds the next workable time slot starting from a given date/time.
 * A workable slot is a continuous period where:
 * - A shift is active for the work center
 * - No maintenance window is blocking
 * 
 * @param fromDate - Start searching from this date/time
 * @param workCenter - Work center with shift definitions
 * @param timezone - Timezone for calculations
 * @returns The next available work slot, or null if none found within search limit
 */
export function findNextWorkableSlot(
  fromDate: DateTime,
  workCenter: WorkCenter,
  timezone: string = 'UTC',
): WorkableSlot | null {
  let searchDate = fromDate.setZone(timezone);
  
  // Search up to 30 days ahead (handles long maintenance windows)
  const searchLimit = searchDate.plus({ days: 30 });
  
  while (searchDate < searchLimit) {
    const dayOfWeek = searchDate.weekday % 7; // Luxon uses 1-7 (Mon-Sun), convert to 0-6 (Sun-Sat)
    
    // Find all shifts for this day of week
    const shiftsToday = workCenter.data.shifts.filter(s => s.dayOfWeek === dayOfWeek);
    
    if (shiftsToday.length === 0) {
      // No shifts today, move to start of next day
      searchDate = searchDate.plus({ days: 1 }).startOf('day');
      continue;
    }

    // Sort shifts by start hour
    shiftsToday.sort((a, b) => a.startHour - b.startHour);

    for (const shift of shiftsToday) {
      const slotStart = searchDate.set({ hour: shift.startHour, minute: 0, second: 0, millisecond: 0 });
      let slotEnd = searchDate.set({ hour: shift.endHour, minute: 0, second: 0, millisecond: 0 });
      
      // Handle overnight shifts (end hour < start hour)
      if (shift.endHour <= shift.startHour) {
        slotEnd = slotEnd.plus({ days: 1 });
      }

      // Skip if this slot has already passed
      if (slotEnd <= fromDate) {
        continue;
      }

      // Adjust start if we're already partway through the shift
      const effectiveStart = slotStart < fromDate ? fromDate : slotStart;
      
      if (effectiveStart >= slotEnd) {
        continue;
      }

      // Check against maintenance windows and split if necessary
      const availableSlot = subtractMaintenanceWindows(
        effectiveStart,
        slotEnd,
        workCenter.data.maintenanceWindows,
        timezone,
      );

      if (availableSlot && availableSlot.durationMinutes > 0) {
        return availableSlot;
      }
    }

    // No valid slots found today, move to next day
    searchDate = searchDate.plus({ days: 1 }).startOf('day');
  }

  return null;
}

/**
 * Subtracts maintenance windows from a time slot.
 * Returns the first available portion of the slot that doesn't overlap
 * with any maintenance window.
 * 
 * @param slotStart - Start of the potential work slot
 * @param slotEnd - End of the potential work slot
 * @param maintenanceWindows - List of blocked periods
 * @param timezone - Timezone for calculations
 * @returns Adjusted slot with maintenance windows excluded, or null if fully blocked
 */
function subtractMaintenanceWindows(
  slotStart: DateTime,
  slotEnd: DateTime,
  maintenanceWindows: MaintenanceWindow[],
  timezone: string,
): WorkableSlot | null {
  let currentStart = slotStart;
  let currentEnd = slotEnd;

  // Sort maintenance windows by start date
  const sortedWindows = [...maintenanceWindows]
    .map(mw => ({
      start: DateTime.fromISO(mw.startDate, { zone: timezone }),
      end: DateTime.fromISO(mw.endDate, { zone: timezone }),
    }))
    .sort((a, b) => a.start.toMillis() - b.start.toMillis());

  for (const mw of sortedWindows) {
    // Check if maintenance window overlaps with our current slot
    const slotInterval = Interval.fromDateTimes(currentStart, currentEnd);
    const mwInterval = Interval.fromDateTimes(mw.start, mw.end);

    if (!slotInterval.overlaps(mwInterval)) {
      // No overlap, continue checking other windows
      continue;
    }

    // There's an overlap - we need to handle it
    if (mw.start <= currentStart && mw.end >= currentEnd) {
      // Maintenance window completely covers our slot
      return null;
    }

    if (mw.start <= currentStart) {
      // Maintenance starts before or at our slot start
      // Move our start to after the maintenance ends
      currentStart = mw.end;
      if (currentStart >= currentEnd) {
        return null;
      }
    } else if (mw.start > currentStart && mw.start < currentEnd) {
      // Maintenance starts within our slot
      // Return the portion before the maintenance window
      // (We'll get the portion after in a subsequent call)
      currentEnd = mw.start;
    }
  }

  if (currentStart >= currentEnd) {
    return null;
  }

  const durationMinutes = currentEnd.diff(currentStart, 'minutes').minutes;
  
  return {
    start: currentStart,
    end: currentEnd,
    durationMinutes,
  };
}

/**
 * Finds the earliest valid start time for a work order at a specific work center.
 * The start time must be during an active shift and not during maintenance.
 * 
 * @param fromDate - Earliest possible start date/time
 * @param workCenter - Work center with shift definitions
 * @param timezone - Timezone for calculations
 * @returns The earliest valid start time
 */
export function findEarliestValidStart(
  fromDate: string | DateTime,
  workCenter: WorkCenter,
  timezone: string = 'UTC',
): DateTime {
  const from = typeof fromDate === 'string'
    ? DateTime.fromISO(fromDate, { zone: timezone })
    : fromDate.setZone(timezone);

  const slot = findNextWorkableSlot(from, workCenter, timezone);
  
  if (!slot) {
    throw new Error(
      `No valid start time found for work center "${workCenter.data.name}" ` +
      `starting from ${from.toISO()}`
    );
  }

  // Return the later of: our requested time or the slot start
  return from > slot.start ? from : slot.start;
}

/**
 * Checks if a specific date/time falls within working hours for a work center.
 * 
 * @param dateTime - Date/time to check
 * @param workCenter - Work center with shift definitions
 * @param timezone - Timezone for calculations
 * @returns True if the time is during a working period
 */
export function isWithinWorkingHours(
  dateTime: string | DateTime,
  workCenter: WorkCenter,
  timezone: string = 'UTC',
): boolean {
  const dt = typeof dateTime === 'string'
    ? DateTime.fromISO(dateTime, { zone: timezone })
    : dateTime.setZone(timezone);

  const dayOfWeek = dt.weekday % 7; // Convert Luxon's 1-7 to 0-6
  const hour = dt.hour;

  // Check if within any shift for this day
  const isInShift = workCenter.data.shifts.some(shift => {
    if (shift.dayOfWeek !== dayOfWeek) {
      return false;
    }
    
    if (shift.endHour > shift.startHour) {
      // Normal shift (doesn't cross midnight)
      return hour >= shift.startHour && hour < shift.endHour;
    } else {
      // Overnight shift
      return hour >= shift.startHour || hour < shift.endHour;
    }
  });

  if (!isInShift) {
    return false;
  }

  // Check if blocked by maintenance window
  const isInMaintenance = workCenter.data.maintenanceWindows.some(mw => {
    const mwStart = DateTime.fromISO(mw.startDate, { zone: timezone });
    const mwEnd = DateTime.fromISO(mw.endDate, { zone: timezone });
    return dt >= mwStart && dt < mwEnd;
  });

  return !isInMaintenance;
}

/**
 * Utility to convert between timezones while preserving the instant.
 * 
 * @param dateTime - Source date/time
 * @param targetTimezone - Target timezone
 * @returns DateTime in the target timezone
 */
export function convertTimezone(
  dateTime: string | DateTime,
  targetTimezone: string,
): DateTime {
  const dt = typeof dateTime === 'string'
    ? DateTime.fromISO(dateTime)
    : dateTime;
  
  return dt.setZone(targetTimezone);
}

/**
 * Returns the maximum (latest) DateTime from an array of DateTimes.
 * 
 * @param dates - Array of DateTimes to compare
 * @returns The latest DateTime, or null if array is empty
 */
export function maxDateTime(...dates: (DateTime | null | undefined)[]): DateTime | null {
  const validDates = dates.filter((d): d is DateTime => d != null);
  
  if (validDates.length === 0) {
    return null;
  }

  return validDates.reduce((max, current) => 
    current > max ? current : max
  );
}

